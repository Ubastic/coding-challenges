{"easy": [{"id": 121, "slug": "best-time-to-buy-and-sell-stock", "title": "Best Time to Buy and Sell Stock", "difficulty": "easy", "latest_solution": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        minprice = float('inf')\n        maxprofit = 0\n        for p in prices:\n            minprice = min(p, minprice)\n            maxprofit = max(p - minprice, maxprofit)\n        return maxprofit"}, {"id": 217, "slug": "contains-duplicate", "title": "Contains Duplicate", "difficulty": "easy", "latest_solution": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        return len(nums) != len({*nums})"}, {"id": 237, "slug": "delete-node-in-a-linked-list", "title": "Delete Node in a Linked List", "difficulty": "easy", "latest_solution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        prev = None\n\n        while node.next:\n            prev, node = node, node.next\n            prev.val = node.val\n\n        prev.next = None"}, {"id": 387, "slug": "first-unique-character-in-a-string", "title": "First Unique Character in a String", "difficulty": "easy", "latest_solution": "class Solution:\n    def firstUniqChar(self, s: str) -> int:\n        checked = set()\n        for i, c in enumerate(s):\n            if c not in checked and c not in s[i+1:]:\n                return i\n            checked.add(c)\n        return -1"}, {"id": 28, "slug": "implement-strstr", "title": "Implement strStr()", "difficulty": "easy", "latest_solution": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n\n        for i in range(len(haystack) - len(needle) + 1):\n            if all(haystack[i + j] == c for j, c in enumerate(needle)):\n                return i\n\n        return -1"}, {"id": 350, "slug": "intersection-of-two-arrays-ii", "title": "Intersection of Two Arrays II", "difficulty": "easy", "latest_solution": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        intersection = []\n        \n        for n in nums1:\n            try:\n                nums2.remove(n)\n                intersection.append(n)\n            except ValueError:\n                pass\n        \n        return intersection\n            "}, {"id": 226, "slug": "invert-binary-tree", "title": "Invert Binary Tree", "difficulty": "easy", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if root:\n            root.left, root.right = root.right, root.left\n            Solution().invertTree(root.left)\n            Solution().invertTree(root.right)\n            return root"}, {"id": 392, "slug": "is-subsequence", "title": "Is Subsequence", "difficulty": "easy", "latest_solution": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        return re.match(\".*\" + \"\".join(f\"{c}.*\" for c in s), t) is not None\n"}, {"id": 14, "slug": "longest-common-prefix", "title": "Longest Common Prefix", "difficulty": "easy", "latest_solution": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        common = []\n        for s in zip(*strs):\n            if s.count(s[0]) == len(s):\n                common.append(s[0])\n            else:\n                break\n\n        return ''.join(common)"}, {"id": 104, "slug": "maximum-depth-of-binary-tree", "title": "Maximum Depth of Binary Tree", "difficulty": "easy", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        def visit(node: TreeNode, depth: int = 0):\n            if not node:\n                return depth\n\n            return max(visit(node.left, depth + 1), visit(node.right ,depth + 1))\n        \n        return visit(root)"}, {"id": 21, "slug": "merge-two-sorted-lists", "title": "Merge Two Sorted Lists", "difficulty": "easy", "latest_solution": "class Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        start = node = None\n\n        while l1 or l2:\n            if l1 is not None and (l2 is None or l1.val < l2.val):\n                val = l1.val\n                l1 = l1.next\n            elif l2 is not None and (l1 is None or l2.val <= l1.val):\n                val = l2.val\n                l2 = l2.next\n            else:\n                break\n\n            if start is None:\n                start = node = ListNode(val)\n            else:\n                node.next = ListNode(val)\n                node = node.next\n\n        return start\n"}, {"id": 283, "slug": "move-zeroes", "title": "Move Zeroes", "difficulty": "easy", "latest_solution": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zeros = 0\n        for n in reversed(nums):\n            if not n:\n                zeros += 1\n                nums.remove(n)\n\n        nums.extend([0] * zeros)"}, {"id": 9, "slug": "palindrome-number", "title": "Palindrome Number", "difficulty": "easy", "latest_solution": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        return str(x) == str(x)[::-1]\n"}, {"id": 112, "slug": "path-sum", "title": "Path Sum", "difficulty": "easy", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        def visit(node: TreeNode, path: int = 0) -> bool:\n            if not node:\n                return False\n            \n            if not node.left and not node.right:\n                return path + node.val == sum\n\n            return visit(node.left, path + node.val) or visit(node.right, path + node.val)\n        \n        return visit(root)"}, {"id": 66, "slug": "plus-one", "title": "Plus One", "difficulty": "easy", "latest_solution": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        reminder = 1\n        for i, n in zip(*map(reversed, (range(len(digits)), digits))):\n            reminder, digits[i] = divmod(n + reminder, 10)\n        \n        if reminder:\n            digits.insert(0, reminder)\n        \n        return digits\n"}, {"id": 231, "slug": "power-of-two", "title": "Power of Two", "difficulty": "easy", "latest_solution": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and bin(n).count(\"1\") == 1"}, {"id": 1203, "slug": "print-in-order", "title": "Print in Order", "difficulty": "easy", "latest_solution": "from threading import Event\n\nclass Foo:\n    def __init__(self):\n        self.f_event = Event()\n        self.s_event = Event()\n\n\n    def first(self, printFirst: 'Callable[[], None]') -> None:\n        printFirst()\n        self.f_event.set()\n\n\n    def second(self, printSecond: 'Callable[[], None]') -> None:\n        self.f_event.wait()\n        printSecond()\n        self.s_event.set()\n\n\n    def third(self, printThird: 'Callable[[], None]') -> None:\n        self.s_event.wait()\n        printThird()"}, {"id": 26, "slug": "remove-duplicates-from-sorted-array", "title": "Remove Duplicates from Sorted Array", "difficulty": "easy", "latest_solution": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        x = None\n        for n in reversed(nums):\n            if n == x:\n                nums.remove(x)\n            x = n\n\n        return len(nums)"}, {"id": 190, "slug": "reverse-bits", "title": "Reverse Bits", "difficulty": "easy", "latest_solution": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        return int(bin(n)[2:].zfill(32)[::-1], 2)"}, {"id": 7, "slug": "reverse-integer", "title": "Reverse Integer", "difficulty": "easy", "latest_solution": "class Solution:\n    def reverse(self, x: int) -> int:\n        n = abs(int(str(x)[::-1].lstrip('0').rstrip('-') or '0')) * (-1) ** (x < 0)\n        return n if -2147483648 <= n <= 2147483647 else 0\n"}, {"id": 344, "slug": "reverse-string", "title": "Reverse String", "difficulty": "easy", "latest_solution": "import math\n\nclass Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        for i in range(math.ceil(len(s) / 2)):\n            s[i], s[-(i + 1)] = s[-(i + 1)], s[i]"}, {"id": 13, "slug": "roman-to-integer", "title": "Roman to Integer", "difficulty": "easy", "latest_solution": "VALUES = {\n    \"I\": 1,\n    \"V\": 5,\n    \"X\": 10,\n    \"L\": 50,\n    \"C\": 100,\n    \"D\": 500,\n    \"M\": 1000,\n}\n\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        num, max_val = 0, \"I\"\n\n        for c in reversed(s):\n            if VALUES[c] >= VALUES[max_val]:\n                max_val = c\n                num += VALUES[c]\n            else:\n                num -= VALUES[c]\n\n        return num"}, {"id": 189, "slug": "rotate-array", "title": "Rotate Array", "difficulty": "easy", "latest_solution": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        for _ in range(k):\n            nums.insert(0, nums.pop())\n        "}, {"id": 783, "slug": "search-in-a-binary-search-tree", "title": "Search in a Binary Search Tree", "difficulty": "easy", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\n        if root is None:\n            return\n        if root.val == val:\n            return root\n        return self.searchBST((root.left if root.val > val else root.right), val)"}, {"id": 35, "slug": "search-insert-position", "title": "Search Insert Position", "difficulty": "easy", "latest_solution": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        return next((i for i, n in enumerate(nums) if n >= target), len(nums))"}, {"id": 136, "slug": "single-number", "title": "Single Number", "difficulty": "easy", "latest_solution": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        cache = set()\n\n        for n in nums:\n            if n in cache:\n                cache.remove(n)\n            else:\n                cache.add(n)\n\n        res, = cache\n        return res"}, {"id": 101, "slug": "symmetric-tree", "title": "Symmetric Tree", "difficulty": "easy", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        def visit(left: TreeNode, right: TreeNode) -> bool:\n            if not left and not right:\n                return True\n            \n            if left and right and left.val == right.val:\n                return visit(left.left, right.right) and visit(right.left, left.right)\n            \n            return False\n        \n        return visit(root, root)"}, {"id": 1095, "slug": "two-city-scheduling", "title": "Two City Scheduling", "difficulty": "easy", "latest_solution": "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        costs = sorted(costs, key=lambda cost: cost[0] - cost[1])\n        return sum(c for c, _ in costs[:len(costs) // 2]) + sum(c for _, c in costs[len(costs) // 2:])\n"}, {"id": 1, "slug": "two-sum", "title": "Two Sum", "difficulty": "easy", "latest_solution": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        diff = {target - n: i for i, n in enumerate(nums)}\n        for i, n in enumerate(nums):\n            if n in diff and diff[n] != i:\n                return [i, diff[n]]"}, {"id": 242, "slug": "valid-anagram", "title": "Valid Anagram", "difficulty": "easy", "latest_solution": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return sorted(s) == sorted(t)"}, {"id": 125, "slug": "valid-palindrome", "title": "Valid Palindrome", "difficulty": "easy", "latest_solution": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        i = 0\n        j = len(s) - 1\n        s = s.lower()\n        while i < j:\n            while i < j and not s[i].isalnum():\n                i += 1\n            while j > i and not s[j].isalnum():\n                j -= 1\n\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n\n        return True"}], "medium": [{"id": 2, "slug": "add-two-numbers", "title": "Add Two Numbers", "difficulty": "medium", "latest_solution": "from itertools import zip_longest\n\n\ndef all_nodes(l: ListNode):\n    while l is not None:\n        yield l.val\n        l = l.next\n\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        ost, node = 0, None\n\n        for a, b in zip_longest(all_nodes(l1), all_nodes(l2), fillvalue=0):\n            n = a + b + ost\n            n, ost = n % 10, n // 10\n\n            if node is None:\n                temp = node = ListNode(n)\n            else:\n                temp.next = ListNode(n)\n                temp = temp.next\n\n        if ost:\n            temp.next = ListNode(ost)\n\n        return node"}, {"id": 94, "slug": "binary-tree-inorder-traversal", "title": "Binary Tree Inorder Traversal", "difficulty": "medium", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        res = []\n\n        def visit(node: TreeNode):\n            if node:\n                visit(node.left)\n                res.append(node.val)\n                visit(node.right)\n\n        visit(root)\n        return res"}, {"id": 102, "slug": "binary-tree-level-order-traversal", "title": "Binary Tree Level Order Traversal", "difficulty": "medium", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n\n        while queue:\n            new_queue = []\n            level = []\n\n            for node in queue:\n                level.append(node.val)\n\n                if node.left:\n                    new_queue.append(node.left)\n\n                if node.right:\n                    new_queue.append(node.right)\n\n            queue = new_queue\n            res.append(level)\n\n        return res"}, {"id": 144, "slug": "binary-tree-preorder-traversal", "title": "Binary Tree Preorder Traversal", "difficulty": "medium", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\n        res = []\n\n        def visit(node: TreeNode):\n            if node:\n                res.append(node.val)\n                visit(node.left)\n                visit(node.right)\n\n        visit(root)\n        return res"}, {"id": 803, "slug": "cheapest-flights-within-k-stops", "title": "Cheapest Flights Within K Stops", "difficulty": "medium", "latest_solution": "from collections import defaultdict\nfrom typing import List, Dict, Tuple\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph: Dict[int, List[Tuple[int, int]]] = defaultdict(list)\n        for node, dst_node, price in flights:\n            graph[node].append((dst_node, price))\n\n        queue: List[Tuple[int, List[int]]] = [(0, [src])]\n\n        while queue:\n            price, path = heappop(queue)\n\n            if path[-1] == dst:\n                return price\n            elif len(path) - 1 > k:\n                continue\n\n            for dst_node, path_price in graph[path[-1]]:\n                heappush(queue, (price + path_price, [*path, dst_node]))\n\n        return -1"}, {"id": 518, "slug": "coin-change-2", "title": "Coin Change 2", "difficulty": "medium", "latest_solution": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        ways = [[0] * (amount + 1) for _ in range(len(coins) + 1)]\n        ways[0][0] = 1\n\n        for i in range(1, len(coins) + 1):\n            ways[i][0] = 1\n\n            for j in range(1, amount + 1):\n                ways[i][j] = ways[i - 1][j] + (0 if j < coins[i - 1] else ways[i][j - coins[i - 1]])\n\n        return ways[-1][amount]"}, {"id": 165, "slug": "compare-version-numbers", "title": "Compare Version Numbers", "difficulty": "medium", "latest_solution": "class Solution:\n    def compareVersion(self, v1: str, v2: str) -> int:\n        v_1 = [*map(int, v1.split('.')), *([0] * (v2.count('.') - v1.count('.')))]\n        v_2 = [*map(int, v2.split('.')), *([0] * (v1.count('.') - v2.count('.')))]\n\n        return (v_1 > v_2) - (v_1 < v_2)\n"}, {"id": 106, "slug": "construct-binary-tree-from-inorder-and-postorder-traversal", "title": "Construct Binary Tree from Inorder and Postorder Traversal", "difficulty": "medium", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        pre_index = len(inorder) - 1\n\n        def visit(start, end):\n            nonlocal pre_index\n\n            if start > end:\n                return None\n\n            node = TreeNode(postorder[pre_index])\n            pre_index -= 1\n\n            if start == end:\n                return node\n\n            root = start + inorder[start: end + 1].index(node.val)\n\n            node.right = visit(root + 1, end)\n            node.left = visit(start, root - 1)\n\n            return node\n\n        return visit(0, len(inorder) - 1)"}, {"id": 105, "slug": "construct-binary-tree-from-preorder-and-inorder-traversal", "title": "Construct Binary Tree from Preorder and Inorder Traversal", "difficulty": "medium", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        pre_index = 0\n\n        def visit(start, end):\n            nonlocal pre_index\n\n            if start > end:\n                return None\n\n            node = TreeNode(preorder[pre_index])\n            pre_index += 1\n\n            if start == end:\n                return node\n\n            root = start + inorder[start: end + 1].index(node.val)\n\n            node.left = visit(start, root - 1)\n            node.right = visit(root + 1, end)\n\n            return node\n\n        return visit(0, len(inorder) - 1)\n"}, {"id": 222, "slug": "count-complete-tree-nodes", "title": "Count Complete Tree Nodes", "difficulty": "medium", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countNodes(self, root: TreeNode) -> int:\n        if root:\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n\n        return 0"}, {"id": 394, "slug": "decode-string", "title": "Decode String", "difficulty": "medium", "latest_solution": "from re import compile, Match\n\nREGEX = compile(r'(\\d+)\\[([^\\[]*?)\\]')\n\n\ndef on_match(match: Match) -> str:\n    count, value = match.groups()\n    return value * int(count)\n\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        while '[' in s:\n            s = REGEX.sub(on_match, s)\n        return s"}, {"id": 380, "slug": "insert-delete-getrandom-o1", "title": "Insert Delete GetRandom O(1)", "difficulty": "medium", "latest_solution": "class RandomizedSet:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.data = set()\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\n        \"\"\"\n        if val in self.data:\n            return False\n\n        self.data.add(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        Removes a value from the set. Returns true if the set contained the specified element.\n        \"\"\"\n        if val in self.data:\n            self.data.remove(val)\n            return True\n\n        return False\n\n    def getRandom(self) -> int:\n        \"\"\"\n        Get a random element from the set.\n        \"\"\"\n        return random.choice([*self.data]) if self.data else None\n        \n\n\n# Your RandomizedSet object will be instantiated and called as such:\n# obj = RandomizedSet()\n# param_1 = obj.insert(val)\n# param_2 = obj.remove(val)\n# param_3 = obj.getRandom()"}, {"id": 3, "slug": "longest-substring-without-repeating-characters", "title": "Longest Substring Without Repeating Characters", "difficulty": "medium", "latest_solution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        arr = set()\n        pos = max_size = 0\n\n        while True:\n            for c in s[pos:]:\n                if c in arr:\n                    max_size = max(len(arr), max_size)\n                    pos += 1\n                    arr.clear()\n                    break\n                else:\n                    arr.add(c)\n            else:\n                return max(len(arr), max_size)"}, {"id": 236, "slug": "lowest-common-ancestor-of-a-binary-tree", "title": "Lowest Common Ancestor of a Binary Tree", "difficulty": "medium", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        def visit(node: 'TreeNode'):\n            if node:\n                left = visit(node.left)\n                right = visit(node.right)\n\n                if not left and node.val in (p.val, q.val):\n                    left = node\n\n                if not right and node.val in (p.val, q.val):\n                    right = root\n\n                if left and right:\n                    return node\n                else:\n                    return left or right\n\n        return visit(root)"}, {"id": 146, "slug": "lru-cache", "title": "LRU Cache", "difficulty": "medium", "latest_solution": "class LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.keys = []\n        self.data = {}\n\n    def mark_as_used(self, key):\n        index = self.keys.index(key)\n        if index != 0:\n            self.keys.insert(0, self.keys.pop(index))\n\n    def get(self, key: int) -> int:\n        if key not in self.data:\n            return -1\n\n        self.mark_as_used(key)\n        return self.data[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.data:\n            if len(self.data) == self.capacity:\n                del self.data[self.keys.pop(-1)]\n            self.keys.insert(0, key)\n        else:\n            self.mark_as_used(key)\n\n        self.data[key] = value"}, {"id": 60, "slug": "permutation-sequence", "title": "Permutation Sequence", "difficulty": "medium", "latest_solution": "import math\n\n\ndef get_permutation(arr: List[int], k: int) -> str:\n    if len(arr) == 1:\n        return str(arr[0])\n\n    index, reminder = divmod(k, math.factorial(len(arr) - 1))\n    return ''.join(str(i) for i in [arr.pop(index), *get_permutation(arr, reminder)])\n\n\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        return get_permutation([i + 1 for i in range(n)], k - 1)\n"}, {"id": 116, "slug": "populating-next-right-pointers-in-each-node", "title": "Populating Next Right Pointers in Each Node", "difficulty": "medium", "latest_solution": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\n\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return None\n        \n        queue = [root]\n        while queue:\n            new_queue = []\n            for node in queue:\n                if node.left: new_queue.append(node.left)\n                if node.right: new_queue.append(node.right)\n\n            if new_queue:\n                node, *others = new_queue\n\n                for n in others:\n                    node.next, node = n, n\n\n            queue = new_queue\n    \n        return root\n"}, {"id": 117, "slug": "populating-next-right-pointers-in-each-node-ii", "title": "Populating Next Right Pointers in Each Node II", "difficulty": "medium", "latest_solution": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\nclass Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return None\n        \n        queue = [root]\n        while queue:\n            new_queue = []\n            for node in queue:\n                if node.left: new_queue.append(node.left)\n                if node.right: new_queue.append(node.right)\n\n            if new_queue:\n                node, *others = new_queue\n\n                for n in others:\n                    node.next, node = n, n\n\n            queue = new_queue\n    \n        return root"}, {"id": 50, "slug": "powx-n", "title": "Pow(x, n)", "difficulty": "medium", "latest_solution": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        return x ** n"}, {"id": 1216, "slug": "print-zero-even-odd", "title": "Print Zero Even Odd", "difficulty": "medium", "latest_solution": "from threading import Event\nfrom itertools import cycle\n\n\nclass ZeroEvenOdd:\n    def __init__(self, n):\n        self.n = n\n        self.even_event = Event()\n        self.odd_event = Event()\n        self.zero_event = Event()\n        self.zero_event.set()\n\n    def zero(self, printNumber: 'Callable[[int], None]') -> None:\n        events = cycle([self.odd_event, self.even_event])\n        for _ in range(self.n):\n            self.zero_event.wait()\n            printNumber(0)\n            self.zero_event.clear()\n            next(events).set()\n\n    def even(self, printNumber: 'Callable[[int], None]') -> None:\n        for i in range(2, self.n + 1, 2):\n            self.even_event.wait()\n            printNumber(i)\n            self.even_event.clear()\n            self.zero_event.set()\n\n    def odd(self, printNumber: 'Callable[[int], None]') -> None:\n        for i in range(1, self.n + 1, 2):\n            self.odd_event.wait()\n            printNumber(i)\n            self.odd_event.clear()\n            self.zero_event.set()"}, {"id": 238, "slug": "product-of-array-except-self", "title": "Product of Array Except Self", "difficulty": "medium", "latest_solution": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        l = len(nums)\n        answer = [0] * l\n        answer[0] = 1\n\n        for i in range(1, l):\n            answer[i] = nums[i - 1] * answer[i - 1]\n\n        r = 1\n        for i in reversed(range(l)):\n            answer[i], r = answer[i] * r, r * nums[i] \n\n        return answer"}, {"id": 406, "slug": "queue-reconstruction-by-height", "title": "Queue Reconstruction by Height", "difficulty": "medium", "latest_solution": "class Solution:\n    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\n        people.sort(key=lambda x: (-x[0], x[1]))\n\n        res = []\n        for p in people:\n            res.insert(p[1], p)\n\n        return res\n"}, {"id": 48, "slug": "rotate-image", "title": "Rotate Image", "difficulty": "medium", "latest_solution": "import numpy as np\n\n\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        array = np.rot90(np.array(matrix), -1)\n        for i in range(len(array)):\n            matrix[i] = [*map(int, array[i])]\n"}, {"id": 137, "slug": "single-number-ii", "title": "Single Number II", "difficulty": "medium", "latest_solution": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        seen = set()\n        double_seen = set()\n\n        for n in nums:\n            if n not in seen:\n                seen.add(n)\n            else:\n                double_seen.add(n)\n\n        res, = seen - double_seen\n        return res\n            "}, {"id": 75, "slug": "sort-colors", "title": "Sort Colors", "difficulty": "medium", "latest_solution": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        stats = Counter(nums)\n        nums[:] = [*([0] * stats[0]), *([1] * stats[1]), *([2] * stats[2]),]"}, {"id": 8, "slug": "string-to-integer-atoi", "title": "String to Integer (atoi)", "difficulty": "medium", "latest_solution": "import re\n\nINT_MAX = 2 ** 31 - 1\nINT_MIN = -2 ** 31\n\nNUMBER = re.compile(r'^[+-]?\\d+')\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        match = NUMBER.search(s.strip())\n        \n        if not match:\n            return 0\n\n        return max(min(int(match.group()), INT_MAX), INT_MIN)"}, {"id": 130, "slug": "surrounded-regions", "title": "Surrounded Regions", "difficulty": "medium", "latest_solution": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        if not board:\n            return\n\n        rows, columns = len(board), len(board[0])\n        to_modify = {(i, j) for j in range(columns) for i in range(rows)}\n\n        queue = [(i, j) for j in (0, columns - 1) for i in range(rows) if board[i][j] == 'O']\n        queue.extend((i, j) for j in range(columns) for i in (0, rows - 1) if board[i][j] == 'O')\n        visited = {*queue}\n\n        while queue:\n            i, j = queue.pop()\n\n            for x_diff, y_diff in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                ii, jj = i + x_diff, j + y_diff\n\n                if 0 <= ii < rows and 0 <= jj < columns and (ii, jj) not in visited and board[ii][jj] == 'O':\n                    visited.add((ii, jj))\n                    queue.append((ii, jj))\n\n        for i, j in to_modify - visited:\n            board[i][j] = 'X'\n"}, {"id": 96, "slug": "unique-binary-search-trees", "title": "Unique Binary Search Trees", "difficulty": "medium", "latest_solution": "def binomialCoeff(n, k):    \n    res = 1\n\n    if k > n - k:  \n        k = n - k\n\n    for i in range(k):  \n        res = (res * (n - i)  ) // (i + 1)\n\n    return res  \n    \nclass Solution:\n    def numTrees(self, n: int) -> int:\n        c = binomialCoeff(2 * n, n)    \n        return c // (n + 1)  \n    "}, {"id": 36, "slug": "valid-sudoku", "title": "Valid Sudoku", "difficulty": "medium", "latest_solution": "import numpy as np\nfrom collections import Counter\nfrom itertools import chain\n\n\nclass Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        array = np.array(board)\n        array_t = array.T\n        digits = {*map(str, range(10)), '.'}\n\n        for l in chain(\n                array,\n                array_t,\n                (\n                        array[i * 3: (i + 1) * 3, j * 3: (j + 1) * 3].flatten()\n                        for i in range(3) for j in range(3)\n                )\n        ):\n            if (\n                    not {*l}.issubset(digits)\n                    or {*Counter(i for i in l if i != '.').values()} not in ({1}, set())\n            ):\n                return False\n\n        return True"}, {"id": 98, "slug": "validate-binary-search-tree", "title": "Validate Binary Search Tree", "difficulty": "medium", "latest_solution": "class Solution:\n    def isValidBST(self, node: TreeNode, min=float('-inf'), max=float('inf')) -> bool:\n        return not node or (\n                min < node.val < max\n                and self.isValidBST(node.left, min, node.val)\n                and self.isValidBST(node.right, node.val, max)\n        )\n\n\n"}, {"id": 468, "slug": "validate-ip-address", "title": "Validate IP Address", "difficulty": "medium", "latest_solution": "from ipaddress import IPv4Address, IPv6Address\nfrom re import search\n\nclass Solution:\n    def validIPAddress(self, IP: str) -> str:\n        try:\n            assert not search(r\"0\\d\", IP)\n            ip = IPv4Address(IP)\n            return \"IPv4\"\n        except:\n            try:\n                assert not search(r\"::\", IP)\n                IPv6Address(IP)\n                return \"IPv6\"\n            except:\n                return \"Neither\""}], "hard": [{"id": 145, "slug": "binary-tree-postorder-traversal", "title": "Binary Tree Postorder Traversal", "difficulty": "hard", "latest_solution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\n        res = []\n\n        def visit(node: TreeNode):\n            if node:\n                visit(node.left)\n                visit(node.right)\n                res.append(node.val)\n\n        visit(root)\n        return res"}, {"id": 174, "slug": "dungeon-game", "title": "Dungeon Game", "difficulty": "hard", "latest_solution": "class Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        height, width = len(dungeon) - 1, len(dungeon[0]) - 1\n        seen = defaultdict(lambda: (float('inf'), float('inf')))\n        queue = [(max(-dungeon[0][0], 0), -dungeon[0][0], [0, 0])]\n\n        while queue:\n            min_health, health, (x, y) = heappop(queue)\n            health = -health\n\n            if x == height and y == width:\n                return max(min_health + 1, 1)\n\n            for x_step, y_step in (1, 0), (0, 1):\n                xx, yy = x + x_step, y + y_step\n\n                if 0 <= xx <= height and 0 <= yy <= width:\n                    new_health = health + dungeon[xx][yy]\n                    new_min_health = -min(-min_health, new_health)\n\n                    if seen[xx, yy] > (-new_health, new_min_health):\n                        seen[xx, yy] = (-new_health, new_min_health)\n                        heappush(queue, (new_min_health, -new_health, [xx, yy]))\n"}, {"id": 4, "slug": "median-of-two-sorted-arrays", "title": "Median of Two Sorted Arrays", "difficulty": "hard", "latest_solution": "from typing import List\nfrom itertools import islice, chain\n\n\ndef sorted_arr(a: List[int], b: List[int]):\n    while a and b:\n        yield a.pop(0) if a[0] < b[0] else b.pop(0)\n    yield from chain(a, b)\n\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        total_len = len(nums1) + len(nums2)\n        index = (total_len - 1) // 2\n\n        if total_len % 2:\n            return sum(islice(sorted_arr(nums1, nums2), index, index + 1))\n        else:\n            return sum(islice(sorted_arr(nums1, nums2), index, index + 2)) / 2"}, {"id": 23, "slug": "merge-k-sorted-lists", "title": "Merge k Sorted Lists", "difficulty": "hard", "latest_solution": "\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        start = node = None\n\n        lists = [l for l in lists if l is not None]\n        while lists:\n            less = min(lists, key=lambda n: n.val)\n\n            if start is None:\n                start = node = ListNode(less.val)\n            else:\n                node.next = ListNode(less.val)\n                node = node.next\n\n            if less.next is None:\n                lists.remove(less)\n            else:\n                lists[lists.index(less)] = less.next\n\n        return start"}, {"id": 297, "slug": "serialize-and-deserialize-binary-tree", "title": "Serialize and Deserialize Binary Tree", "difficulty": "hard", "latest_solution": "def serialize(node, arr):\n    if not node:\n        arr.append('*')\n    else:\n        arr.append(node.val)\n        serialize(node.left, arr)\n        serialize(node.right, arr)\n\n    return arr\n\n\ndef deserialize(arr: list):\n    if not arr:\n        return\n\n    val = arr.pop(0)\n    if val == '*':\n        return\n\n    node = TreeNode(int(val))\n    node.left = deserialize(arr)\n    node.right = deserialize(arr)\n\n    return node\n\n\nclass Codec:\n    def serialize(self, root) -> str:\n        return ' '.join(map(str, serialize(root, [])))\n\n    def deserialize(self, data):\n        return deserialize(data.split())"}]}